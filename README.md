# GoppaDecorder(Goppie)


20200619

今、一つのアルゴリズムのアイデアを試しています。これができれば符号でIDベース暗号が作れるかもしれません。
こういう思い付きは往々にして無価値であることが多いので、信じないでください。

今のままだと複数の組み合わせができる（１対１でない）可能性があるのでその場合どうなるかはよくわかりません。
例えば、現行のPoWにしてもハッシュ値が衝突している場合があるので、複数のデータの候補があること自体は大して問題にならない気がします。
ビットコインの場合、マイニングの作業は特定のフォーマットに合致するハッシュ値を探すという計算をスパコンでしますが、
符号で同じようなことをする場合、任意のシンドロームに対応するエラーと符号の対を探すという計算にマイニングが使えるのではと思っています。
鍵を見つけた人には報酬が支払われる仕組みです。
そんなことをしなくても普通にペアリングを使えばいいだろっていう話もあるんですが、楕円曲線はPQCではないので却下です。
PoWに依存しない決定性アルゴリズムが見つかればいいのですが、鍵を見つける計算にPoWを使うのは邪道というか完全に間違っている気がしますね。
まだイメージを膨らませている状態なので理解してませんｗ。
そのうちどう間違っていることに気が付くと思います。
つまりやりたいこととしては、マイニングという計算を利用してIDベース暗号を用いたPKIを実現しようというものです。
IDベース暗号には鍵発行センターのような役割をもつ仕組みが必要なわけですが、これはかなり強力な権限があるので実際にそのようなセンターを作るのは非現実的です。
そこで鍵発行センターの代わりにブロックチェーンを使ってうまく実現させるためのアイデアが必要になります。
ブロックチェーンが鍵に当事者自身のものであることの信用を与えるための活躍させたい・・・。
今は確率的アルゴリズムなので計算量による力づくの計算が必要になりますが、決定性アルゴリズムができればPoWは必要なくなります。
暗号理論自体が計算量によって安全性を保障するようにできているので、今の時点だとPoW以外に解決方法がないように思えます。
また力づくの計算無しでPoWのような仕組みを実現する方法も考案中です。（PoSと呼ばれる方式が存在しますが、そのままでは使えません）

あるいはこの正直な計算が一方向性を持つなら、この問題を使った新しい暗号も作れるのかもしれません。（ここまでは符号の問題に基づいている）


追記：ここで符号理論の常識からはみ出してみましょう。（ここからの議論は、もはや符号ではない）

PoWに依存しない方法を考えます。
通常、エラーとシンドロームが１対１の関係であるためには、エラーベクトルの重みが特定の数に決まっていなければなりません。
しかし、もしこの条件を取り除いてシンドロームと同じサイズのエラーを許せば、
部分符号の逆行列を計算するだけでどのような符号からも簡単にシンドロームに対応するエラーベクトルが決定できるかもしれない。
つまり、シンドロームと符号の特定の位置さえ決まってしまえば、それに対応するエラーベクトルを計算することは簡単だと思われます。
しかしそのような場合でも、長い符号のどの位置にそのベクトルが来るのか計算できなければ組み合わせ論的な計算爆発が起きて安全であることが保証できます。
この場合、秘密鍵はエラーの位置です。
バイナリ符号の場合は、値が変化しないのでこの方法がうまくいきそうな予感・・・。（検証はしてません）
異なる複数の符号間で１つのシンドロームに対応するエラーベクトルが生成できるかもしれない。
しかし、これではどんなベクトルであろうと答えになるので、エラーパターンのハッシュ値かHMACと併用する必要がありますね。
（これは多重線形写像だろうか?という疑問があるけど、それは自分がペアリングの一般化を理解していない証拠でもある）

例えば、３２バイトの任意のシンドローム（例えばメールアドレス）に対応するエラーベクトルを計算したいものとする。
この場合、リードソロモン符号を使うなら、このシンドロームに対応するエラーを計算するために、任意の３２個の位置から符号列を取り出す。
そうして作られた正方行列の逆行列を計算してやり、シンドロームにかけてやれば、この場合メールアドレスに対応するエラーベクトルが決まるという訳です。

しかしこの問題は符号であるという前提を無視しているので、単なる長方形をした大きな行列で計算しているのと変わりがありません。
どちらかといえばPKP（Permuted Kernel Problem）と呼ばれる問題に近いのかもしれません。
誰も格子暗号が長方形をした行列を公開鍵に持つ暗号だと言わないだけで、もしかしたらこの方法が格子に基づく暗号なのかもしれない。（ちなみに格子暗号は全く知らない）
ランダム行列に対する特定の入出力計算に関する問題になるので、結局訂正限界を無視した前提を利用するのは、符号に関する問題ではないですね。

結論：しかしこれはアフィン暗号と同じになってしまうので簡単に解読できますね。
小さな情報だけで復号できるところが符号ベースの暗号の強みというものでしょうか。
誰も格子暗号が長方形をした行列を公開鍵に持つ暗号だと言わないだけで、格子暗号みたいなものかもしれないです。
ちなみに格子暗号は全く知りません。ｗ

で、

エンジニアさんの意見では、ビットコインのマネをしてはいけないという忠告を受けている。
理由は、PoWは環境に良くない、PoS（プルーフ　オブ　ステーク）のほうがいいというのです。
これは金持ちが得をするという新自由主義みたいなアイデアなのですが、
一方ではマイニングが努力を続けた者が得をするという感じなので、環境にいいという感じでしょうか。
この方式はイーサリアムを使ったピアコインで実現されているそうです。
他にもリップルコインという仮想通貨で使われる、
プルーフオブコンセンサスなるものもあるようで、今後色んな設計思想のシステムができてきそうです。
どちらにしてもこの分野はラットイヤーなので予測不可能ですけどねｗ

暗号の研究は大企業よりベンチャーのほうが圧倒的に有利な気がするんですけどどうなんでしょう。

発明は勢いと思い付き！ｗ


20200617

https://herumi.github.io/ango/

これを見て、楕円曲線を使わないでペアリングみたいなことがやってみたいと思うようになった。（ペアリングだけなら高校生でもできる）
ちなみにここに書いてある新しい暗号というのは、ほとんど全部ペアリング関数の応用であって、
その基礎となるECDLPが量子計算機に弱いことから比較的短命に終わる可能性がある。
私のやっていることが無駄にならなければいいのだが。
この際、符号さえ使っていれば何でもいいから次世代暗号になってほしい。

あと今ブロックチェーンの勉強中です。


20200606

エンジニアさんから指摘されたodegのバグを取って、次数の計算をodegに統一した。


20200531

ゼフ対数を出力するecole.cが動かないとのことなので、動くやつをアップロードしました。

20200601

keygen関数が動かない（エラーになる）ので、detを有効にしました。


20200517

更新してないのに見に来てくれてありがとう。

数学をやるので、暫くの間更新しません。ブロックチェーンの実装をするためです。
では、またいつか。


１．プログラム実行に当たって(oplib.c)　20200304

make

とやれば出来ます。
出力の第一段目はエラーの位置と値をユークリッドアルゴリズムで計算したもの、(decode関数)
第二は復号法であるパターソンアルゴリズムでバイナリエラーの位置を出力したものになります。(pattarson関数)


