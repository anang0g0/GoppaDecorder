# GoppaDecorder(Goppie)


20200619

今、一つのアルゴリズムのアイデアを試しています。これができれば符号でIDベース暗号が作れるかもしれません。
こういう思い付きは往々にして無価値であることが多いので、信じないでください。

今のままだと複数の組み合わせができる（１対１でない）可能性があるのでその場合どうなるかはよくわかりません。
例えば、現行のPoWにしてもハッシュ値が衝突している場合があるので、複数のデータの候補があること自体は大して問題にならない気がします。
ビットコインの場合、マイニングの作業は特定のフォーマットに合致するハッシュ値を探すという計算をスパコンでしますが、
符号で同じようなことをする場合、任意のシンドロームに対応するエラーと符号の対を探すという計算にマイニングが使えるのではと思っています。
鍵を見つけた人には報酬が支払われる仕組みです。
そんなことをしなくても普通にペアリングを使えばいいだろっていう話もあるんですが、楕円曲線はPQCではないので却下です。
PoWに依存しない決定性アルゴリズムが見つかればいいのですが、鍵を見つける計算にPoWを使うのは邪道というか完全に間違っている気がしますね。
まだイメージを膨らませている状態なので理解してませんｗ。
そのうちどう間違っていることに気が付くと思います。
つまりやりたいこととしては、マイニングという計算を利用してIDベース暗号を用いたPKIを実現しようというものです。
IDベース暗号には鍵発行センターのような役割をもつ仕組みが必要なわけですが、これはかなり強力な権限があるので実際にそのようなセンターを作るのは非現実的です。
そこで鍵発行センターの代わりにブロックチェーンを使ってうまく実現させるためのアイデアが必要になります。
ブロックチェーンが鍵に当事者自身のものであることの信用を与えるための活躍させたい・・・。
今は確率的アルゴリズムなので計算量による力づくの計算が必要になりますが、決定性アルゴリズムができればPoWは必要なくなります。
暗号理論自体が計算量によって安全性を保障するようにできているので、今の時点だとPoW以外に解決方法がないように思えます。
また力づくの計算無しでPoWのような仕組みを実現する方法も考案中です。（PoSと呼ばれる方式が存在しますが、そのままでは使えません）

あるいはこの正直な計算が一方向性を持つなら、この問題を使った新しい暗号も作れるのかもしれません。（ここまでは符号の問題に基づいている）

で、

エンジニアさんの意見では、ビットコインのマネをしてはいけないという忠告を受けている。
理由は、PoWは環境に良くない、PoS（プルーフ　オブ　ステーク）のほうがいいというのです。
これは金持ちが得をするという新自由主義みたいなアイデアなのですが、
一方ではマイニングが努力を続けた者が得をするという感じなので、環境にいいという感じでしょうか。
この方式はイーサリアムを使ったピアコインで実現されているそうです。
他にもリップルコインという仮想通貨で使われる、
プルーフオブコンセンサスなるものもあるようで、今後色んな設計思想のシステムができてきそうです。
どちらにしてもこの分野はラットイヤーなので予測不可能ですけどねｗ

暗号の研究は大企業よりベンチャーのほうが圧倒的に有利な気がするんですけどどうなんでしょう。

発明は勢いと思い付き！ｗ


20200617

https://herumi.github.io/ango/

これを見て、楕円曲線を使わないでペアリングみたいなことがやってみたいと思うようになった。（ペアリングだけなら高校生でもできる）
ちなみにここに書いてある新しい暗号というのは、ほとんど全部ペアリング関数の応用であって、
その基礎となるECDLPが量子計算機に弱いことから比較的短命に終わる可能性がある。
私のやっていることが無駄にならなければいいのだが。
この際、符号さえ使っていれば何でもいいから次世代暗号になってほしい。

あと今ブロックチェーンの勉強中です。


20200606

エンジニアさんから指摘されたodegのバグを取って、次数の計算をodegに統一した。


20200531

ゼフ対数を出力するecole.cが動かないとのことなので、動くやつをアップロードしました。

20200601

keygen関数が動かない（エラーになる）ので、detを有効にしました。


20200517

更新してないのに見に来てくれてありがとう。

数学をやるので、暫くの間更新しません。ブロックチェーンの実装をするためです。
では、またいつか。


１．プログラム実行に当たって(oplib.c)　20200304

make

とやれば出来ます。
出力の第一段目はエラーの位置と値をユークリッドアルゴリズムで計算したもの、(decode関数)
第二は復号法であるパターソンアルゴリズムでバイナリエラーの位置を出力したものになります。(pattarson関数)


