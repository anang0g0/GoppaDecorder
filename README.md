# GoppaDecorder

１．プログラム実行に当たって(oplib.c)　20200304

make

とやれば出来ます。
出力の第一段目はエラーの位置と値をユークリッドアルゴリズムで計算したもの、(decode関数)
第二は復号法であるパターソンアルゴリズムでバイナリエラーの位置を出力したものになります。(pattarson関数)

２．作るに至った経緯

耐量子計算機暗号のコアの一つとして、古典的Goppa符号の復号法ができれば良い。ここでは暗号化に必要な関数を作りました。
現在のところ、2の拡大体に関する復号です。バグがあります。ベータバージョンです。マニュアルもまだ書いてません。

このコードを実装するのに使った書籍は、Oliver PretzelのError-Correcting Codes and Finite Fieldsです。

その他英語の論文についてはdiary.txtを参照してください。

このコードの最終目的は軍事レベルの暗号を作ることで、Niederreiter暗号を目指しています。鍵はでかいです。
毎月たくさんの新型が生まれている中で、なぜ改良版を使わないのかという人もいるかもしれませんが、
一番古いオーソドックスな技術が一番安全だし使えると思ってやっています。動かすときはLinuxでどうぞ。
コアダンプしないように作ってあるつもりです。（何らかの標準出力がある）
またブロックチェーン技術のためにネット上にあった自作でないSHA3を使い、電子署名モジュールは作るつもりです。
誰も作ってないようなので作りました。

実装は汚いコードですが、ポインタやオブジェクト指向を知らないので素人レベルのコードです。プロなら読めると思います。
全部で2000行くらいしかないです。
いつか勇者が現れて、私のコードを凌ぐ素晴らしいプログラムを作ってくれることを祈ります。
組み込み開発や、JavaScriptなんかにも直接移植できるのではないでしょうか。処理速度が遅いから無理かもしれないけど、
最適化は今後の課題です。まだプロセッサの能力をフルに発揮できていません。

残念ながらまだOpenMPには対応してません。
やり方が今一つよくわからないのですが、行列を並列計算させようとしても変な値になってしまいうまく並列化できません。
ちなみに開発環境は、LinuxでCPUはAMD　Ryzen7　2700Xです。マルチコアの意味がまるでないｗ。
ただその気になればパソコン用のCPUであれば、アセンブラマクロかなんかを使って、コア内で並列処理できると思います。
AMDのSIMDは遅いという評判ですがｗ。

参考文献を開発日記の別ファイルに移しました。今後ここにはマニュアル的なコードを書きたいと思います。
