# GoppaDecorder

１．プログラム実行に当たって(oplib.c)　20200304

make

とやれば出来ます。
出力はエラーの位置と値をユークリッドアルゴリズムで計算したもの、第二の復号法であるパターソンアルゴリズムでバイナリエラーの位置を出力したものになります。

２．作るに当たった経緯

耐量子計算機暗号のコアの一つとして、古典的Goppa符号の復号法にかかっているので、ここでは暗号化に必要な関数を作りました。
現在のところ、2の拡大体に関する復号です。バグがあります。
このコードを実装するのに使った書籍は、Oliver PretzelのError-Correcting Codes and Finite Fieldsです。
このコードの最終目的は軍事レベルの暗号を作ることで、Niederreiter暗号を目指しています。鍵はでかいです。
毎月たくさんの新型が生まれている中で、なぜ改良版を使わないのかという人もいるかもしれませんが、
一番古いオーソドックスな技術が一番安全だし使えると思ってやっています。動かすときはLinuxでどうぞ。
コアダンプしないように作ってあるつもりです。（何らかの標準出力がある）
またブロックチェーン技術のためにネット上にあった自作でないSHA3を使い、電子署名モジュールは作るつもりです。
誰も作ってないようなので作りました。

実装は汚いコードですが、ポインタやオブジェクト指向を知らないので初心者レベルのコードです。プロなら読めると思います。
全部で2000行くらいしかないです。
JavaScriptなんかにも直接移植できるのではないでしょうか。

こういう暗号のいいところは巨大整数を使ってないので簡単に組み込みレベルのプログラムに使えるという事です。
組み込み開発用に使うとしても、ほぼそのまま動くでしょう。残念ながらまだOpenMPには対応してません。
やり方が今一つよくわからないのですが、行列を並列計算させようとしても変な値になってしまいうまく並列化できません。
ちなみに開発環境は、LinuxでCPUはAMD　Ryzen7　2700Xです。マルチコアの意味がまるでないｗ。
ただその気になればパソコン用のCPUであれば、アセンブラマクロかなんかを使って、コア内で並列処理できると思います。
AMDのSIMDは遅いという評判ですがｗ。

３．開発日記

20191218

GF(4096)上定義されたバイナリGoppa符号を生成できるようになった。この計算には14分もかかるので今後何か別の計算方法を考えないといけない。(oplib.cpp)
因みに、QC-MDPCなんで邪道だと思っているので、オリジナルの古典的Goppa符号を使っている。

同時に、LU分解法にヒントを得た可逆スクランブル行列を生成できるようになった。(lu.c)

公開鍵のパラメーターは、[n,k,t]=[4096,2040,85]である。

20191221

GF4096において、型をunsigned shortにして、バイナリ生成行列を出力させる鍵生成まで完成。(oplib.cpp)

20191226

開発メモ。誤りロケータだけは実装完了。バイナリバージョンの場合は誤りの位置を決定するだけで済むのでこれで完成。(chen.c)

既知のバグ：誤りの値を計算するときに、0になる場合がある。これは誤りロケータと、誤り値関数にまだ最小公倍数、つまり
1次式が残されている証拠で、この点を解決するためにユークリッドアルゴリズムに多少の改良を加える必要がある。この点については
来年に目標にしたい。(oplib.c)

20191227

誤りロケータもバグっていることが判明。しかし体力の限界。もう十日近く15時間やってるけど、そろそろ限界。
今のところ一番確実に動くのがchen.cなので、これをもとにバグ取りをしようと思う。でも今年はもうおしまい。
わずか１０００行のプログラムの挙動が理解できない私は低能だｗ

手で計算できないものは計算機を使って計算させてバグ取りをしないといけないし、デバック用のプログラムも書かないといけないのでまた来年。

20191229

バグを最後の1つに絞り込めた。現在デバッグモジュールを作成中。

20191230

ついにバグを突き止めた。生成行列の特定の列が０ベクトルだったという落とし穴がｗ。アルゴリズムは間違いなかった。
どこを探しても問題なかったから、まさかと思って調べてみたら０だったというｗ。しかも１１個もあった。
陽性かくにん、よかった。あとは０のない生成行列をどう作るかで、トレースチェックだけすればいいんじゃないかと思うのだが違うんだろうか？
これでもかなりマシになったほうなのだが、まだ重解を持つ可能性があるので完全にバグがないとは言えない。
とりあえずバイナリの場合は誤り位置だけ正確に計算できればいいので、これで完成しているはず。
あとは実際に公開鍵を使って暗号化復号化をするというIOの部分を作ることになる。あとソースにコメントもつけないといけない。(oplib.c)

20191231

とりあえずバグはなくなったはずなのですが、まだあるかもしれません。そしてこのコードをどういう形で使うのかはまだ決めてません。
PGPのような完璧なアプリを作るのはちょっと荷が重いし、Cの初心者レベルのコードなので興味のある人が最適化したり、もっとエレガントな
コードを書いてくれればいいのですが。とりあえず趣味でやった割にはよくできたと自分を褒めてあげたいですｗ。

20200131

https://csrc.nist.gov/projects/post-quantum-cryptography/round-2-submissions

アメリカのNISTで進んでいる次世代公開鍵暗号の選定、第2ラウンドまでにMcEliece暗号が残っているようです。今の所符号に基づく暗号と講師に基づく暗号が拮抗しているようです。私もアセンブリマクロを使って最適化してみようかな。頑張れMcEliece！

https://klevas.mif.vu.lt/~skersys/vsd/crypto_on_codes/goppamceliece.pdf

入れ知恵になるかもしれないですがこれも参考にしてみたいと思います。どうも外部ライブラリを使った実装ばかりで私みたいに一枚岩の自己完結プログラムがないようで。

20200202

https://en.wikipedia.org/wiki/Binary_Goppa_code#Decoding

これのおかげでやっとパターソンアルゴリズムを理解できた。シンドローム多項式の逆多項式はゴッパ多項式が既約のとき、ユークリッドアルゴリズムで
計算できる。そしてバイナリGoppa符号の場合、符号長は変わらず次元だけが縦に引き伸ばされるので、シンドローム多項式は拡大体のときと同じ多項式である。
このとき逆多項式とその平方が計算できるので、解くべき誤り位置関数の次数はシンドローム多項式の半分になる。だから拡大体のときより
Goppa多項式の次数は半分で済む。ということはバイナリバージョンを作らなければならない。やる気が出たらやろう。

http://lupus.is.kochi-u.ac.jp/shiota/misc/field/FiniteField.html

あとgithubにはなかったけれど、プロが書いたMcEliece暗号のデモがあって、エレガントに64ビットに最適化されていて鍵生成はものすごく早かった。
本来ならこうあるべきだけど自分にはその実力がない。

まだ理解があやふやな部分があるので、ｔ個のエラーを訂正するのにｔ次規約多項式の自乗を使ってｔ個のエラーを訂正すれば今の方法を変更しなくても
済むだろうと思った。Goppa多項式の次数は半分に減るので結果は同じだ。アルゴリズムを保ったまま秘密多項式の次数を下げられる。


20200209

https://digitalcommons.csbsju.edu/cgi/viewcontent.cgi?article=1019&context=honors_theses

これもすごい。

20200222

パターソンアルゴリズムを完全実装しました。このアルゴリズムの実現のために多項式の平方根を計算する関数などを追加しました。
我ながらいい感じで使えているのでよかったと思います。ほかの人が満足するかわかりませんがｗ。このアルゴリズムによって、
ｔ次の多項式に対してt個のバイナリエラーが訂正できます。できるかどうかわかりませんでしたができました。(polib.c)

20200227

いよいよコードレビュー。まだomodとかの終了条件を理解してないのでそこから始めることになる。インデントとかは後回しになるかも。
パラメータを変更した。変更後のパラメータは[n,k,t]=[6688,3328,256]である。

アルゴリズムの検証作業に入ります。元ネタはここー＞

https://github.com/davidhoo1988/Code_Based_Cryptography_Python

こういうのがあったんだけど古くて動かない。GF2で既約な多項式を見つけるのは早いけど、拡大体上で既約な多項式を見つけるのは
とても遅い。なので、やはりランダムに取ってきて使える鍵だけを使うほうが早い気がする。正攻法より効率的かも。

20200228

文献の追加。バグトラップを仕掛けてバグを見つけています。ユークリッドの方はほぼ完璧なんですが、パターソンアルゴリズムでエラーロケーター
が計算できたり出来なかったりしているバグを見つけて修正方法を考えています。既約多項式なら完全なので、先に正しい鍵を用意するのが早いのかも
しれませんが、もしそれでだめだったらアルゴリズムのバグですね。
でも拡大体上で既約多項式を見つけるのはsagemathでもすごく時間がかかるので悩んでいます。

https://www.hyperelliptic.org/tanja/students/m_marcus/whitepaper.pdf

20200229

バグが取れた。基本計算は完成したので、これから電子署名と暗号通貨を作ります。

https://classic.mceliece.org/

20200303

今日は暗号化関数の前処理としてハッシュ関数の他の人が書いた使えそうなリポジトリを探してコピーして改ざんした。
SHA3を使う予定。OAEP処理するため。

20200304

サブフォルダdecomp内の、分割コンパイルできるように切り離されたソースと簡単なMakefileを置き換えた。
更にハッシュ関数としてsha3を他のリポジトリからcloneして暗号化関数に使用した。
main関数の中にあったシンドローム計算のための処理を関数に分離した。
私がこれでいいんだからこれでいいのだ。
今の所実用レベルのパラメータを実装したものは見当たらない。解読されているような少し昔の方式があるだけだ。
これが気に入らないというなら自分で論文を読んで1から書くか、改造すればいいだけであって分割コンパイルもインデントも私は必要としていない。
暗号化ができればそれでいいのだ。そういうことができるプロもいるだろうからその人の実装を待てばいい。

20200305

512ビットの秘密鍵を暗号化復号化できるようになった。後はファイルやバッファも暗号化できるようにしたい。

バイナリ公開鍵は半分しか作ってないので、それも完成させる必要があるけど、今はこれで十分な気がする。

20200306

蛇足かもしれないけどファイルの暗号化復号化の関数を作った。
復元したエラーベクトルにハッシュ関数をかけて、そのハッシュ値をファイルのデータにXORして暗号化する公開鍵/秘密鍵のコンパチブル関数。
